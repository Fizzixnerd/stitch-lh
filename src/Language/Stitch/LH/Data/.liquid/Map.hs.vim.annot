1:1-1:1::Language.Stitch.LH.Data.Map.$trModule :: "GHC.Types.Module"
48:1-48:7::Language.Stitch.LH.Data.Map.lookup :: "forall a b <p :: b -> Bool>.\n(GHC.Classes.Ord<[]> a) =>\nx2:a -> x3:(Data.Map.Internal.Map a {VV : b<p> | true}) -> {r : (GHC.Maybe.Maybe {VV : b<p> | true}) | not (Set_mem x2 (mapKeys x3)) <=> r == Nothing}"
48:8-48:9::a :: "a"
48:10-48:11::m :: "(Data.Map.Internal.Map a {VV : b | papp1 p VV})"
48:21-48:22::a :: "{VV : a | VV == a}"
48:23-48:24::m :: "{v : (Data.Map.Internal.Map a {VV : b | papp1 p VV}) | v == m}"
67:1-67:7::Language.Stitch.LH.Data.Map.insert :: "forall a b <p :: b -> Bool>.\n(GHC.Classes.Ord<[]> a) =>\na -> {VV : b<p> | true} -> (Data.Map.Internal.Map a {VV : b<p> | true}) -> (Data.Map.Internal.Map a {VV : b<p> | true})"
67:8-67:9::a :: "a"
67:10-67:11::b :: "{VV : a | papp1 p VV}"
67:12-67:13::m :: "(Data.Map.Internal.Map a {VV : b | papp1 p VV})"
67:23-67:24::a :: "{VV : a | VV == a}"
67:25-67:26::b :: "{VV : a | papp1 p VV\n          && VV == b}"
67:27-67:28::m :: "{v : (Data.Map.Internal.Map a {VV : b | papp1 p VV}) | v == m}"
77:1-77:6::Language.Stitch.LH.Data.Map.empty :: "forall a b <p :: b -> Bool>.\n(Data.Map.Internal.Map a {VV : b<p> | true})"
77:17-77:19::GHC.Tuple.() :: "{v : () | v == ()}"
85:1-85:8::Language.Stitch.LH.Data.Map.goEmpty :: "forall a b .\nx1:() -> {VV : (Data.Map.Internal.Map a b) | VV == goEmpty x1\n                                             && VV == goEmpty ()}"
85:14-85:24::Language.Stitch.LH.Data.Map.goEmpty :: "forall a b .\nx1:() -> {VV : (Data.Map.Internal.Map a b) | VV == goEmpty x1\n                                             && VV == goEmpty ()}"
85:22-85:24::GHC.Tuple.() :: "{v : () | v == ()}"