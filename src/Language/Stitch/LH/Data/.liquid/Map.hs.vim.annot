1:1-1:1::Language.Stitch.LH.Data.Map.$trModule :: "GHC.Types.Module"
47:1-47:7::Language.Stitch.LH.Data.Map.lookup :: "forall a b <p :: b -> Bool>.\n(GHC.Classes.Ord<[]> a) =>\nx2:a -> x3:(Data.Map.Internal.Map a {VV : b<p> | true}) -> {r : (GHC.Maybe.Maybe {VV : b<p> | true}) | not (Set_mem x2 (mapKeys x3)) <=> r == Nothing}"
47:8-47:9::a :: "a"
47:10-47:11::m :: "(Data.Map.Internal.Map a {VV : b | papp1 p VV})"
47:21-47:22::a :: "{VV : a | VV == a}"
47:23-47:24::m :: "{v : (Data.Map.Internal.Map a {VV : b | papp1 p VV}) | v == m}"
66:1-66:7::Language.Stitch.LH.Data.Map.insert :: "forall a b <p :: b -> Bool>.\n(GHC.Classes.Ord<[]> a) =>\na -> {VV : b<p> | true} -> (Data.Map.Internal.Map a {VV : b<p> | true}) -> (Data.Map.Internal.Map a {VV : b<p> | true})"
66:8-66:9::a :: "a"
66:10-66:11::b :: "{VV : a | papp1 p VV}"
66:12-66:13::m :: "(Data.Map.Internal.Map a {VV : b | papp1 p VV})"
66:23-66:24::a :: "{VV : a | VV == a}"
66:25-66:26::b :: "{VV : a | papp1 p VV\n          && VV == b}"
66:27-66:28::m :: "{v : (Data.Map.Internal.Map a {VV : b | papp1 p VV}) | v == m}"
76:1-76:6::Language.Stitch.LH.Data.Map.empty :: "forall a b <p :: b -> Bool>.\n(Data.Map.Internal.Map a {VV : b<p> | true})"
76:17-76:19::GHC.Tuple.() :: "{v : () | v == ()}"
84:1-84:8::Language.Stitch.LH.Data.Map.goEmpty :: "forall a b .\nx1:() -> {VV : (Data.Map.Internal.Map a b) | VV == goEmpty x1\n                                             && VV == goEmpty ()}"
84:14-84:24::Language.Stitch.LH.Data.Map.goEmpty :: "forall a b .\nx1:() -> {VV : (Data.Map.Internal.Map a b) | VV == goEmpty x1\n                                             && VV == goEmpty ()}"
84:22-84:24::GHC.Tuple.() :: "{v : () | v == ()}"