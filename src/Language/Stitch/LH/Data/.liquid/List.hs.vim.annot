1:1-1:1::Language.Stitch.LH.Data.List.$trModule :: "GHC.Types.Module"
32:1-32:6::Language.Stitch.LH.Data.List.empty :: "forall a .\n{VV : [a] | VV == []\n            && length VV == 0}"
39:1-39:5::Language.Stitch.LH.Data.List.cons :: "forall a .\nx1:a -> x2:[a] -> {VV : [a] | VV == : x1 x2\n                              && length VV == 1 + length x2}"
39:6-39:7::a :: "a"
39:8-39:9::b :: "[a]"
39:12-39:13::a :: "{VV : a | VV == a}"
39:14-39:15::b :: "{v : [a] | v == b\n           && len v >= 0\n           && length v >= 0}"
46:1-46:7::Language.Stitch.LH.Data.List.elemAt :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> {VV : [a] | length VV > x1} -> a"
46:18-46:19::x :: "{VV : a | VV == x}"
47:19-47:34::Language.Stitch.LH.Data.List.elemAt :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> {VV : [a] | length VV > x1} -> a"
47:26-47:31::lq_anf$##7205759403792804226 :: "GHC.Types.Int"
47:27-47:28::ds_d2KD :: "{v : GHC.Types.Int | v >= 0}"
47:29-47:30::lq_anf$##7205759403792804225 :: "GHC.Types.Int"
47:32-47:34::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0}"
57:1-57:5::Language.Stitch.LH.Data.List.take :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> {VV : [a] | length VV >= x1} -> {VV : [a] | length VV == x1}"
57:12-57:14::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | v == []\n                                                  && len v == 0\n                                                  && length v == 0} | VV == []}"
58:17-58:18::x :: "{VV : a | VV == x}"
58:19-58:34::lq_anf$##7205759403792804234 :: "[a]"
58:25-58:30::lq_anf$##7205759403792804233 :: "GHC.Types.Int"
58:26-58:27::ds_d2Ki :: "{v : GHC.Types.Int | v >= 0}"
58:28-58:29::lq_anf$##7205759403792804232 :: "GHC.Types.Int"
58:31-58:33::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0}"
65:1-65:7::Language.Stitch.LH.Data.List.length :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | VV == length x1\n                                && VV >= 0}"
65:13-65:14::lq_anf$##7205759403792804236 :: "{v : GHC.Prim.Int# | v == 0}"
66:17-66:18::lq_anf$##7205759403792804238 :: "GHC.Types.Int"
66:21-66:30::lq_anf$##7205759403792804239 :: "{v : GHC.Types.Int | v == length xs\n                     && v >= 0}"
66:28-66:30::xs :: "{v : [a] | v == xs\n           && len v >= 0}"
76:1-76:7::Language.Stitch.LH.Data.List.append :: "forall a .\nx1:[a] -> x2:[a] -> {VV : [a] | length VV == length x1 + length x2}"
76:11-76:13::ys :: "[a]"
76:16-76:18::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"
77:20-77:21::x :: "{VV : a | VV == x}"
77:22-77:36::lq_anf$##7205759403792804241 :: "{v : [a] | v == append xs ys\n           && length v == length xs + length ys}"
77:30-77:32::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0}"
77:33-77:35::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"
86:1-86:13::Language.Stitch.LH.Data.List.appendLength :: "forall a .\nx1:[a] -> x2:[a] -> {VV : () | length (append x1 x2) == length x1 + length x2}"
86:14-86:16::xs :: "[a]"
86:17-86:19::ys :: "[a]"
86:22-86:29::Language.Haskell.Liquid.ProofCombinators.trivial :: "{v : () | v == trivial}"
86:32-86:44::lq_anf$##7205759403792804242 :: "{v : [a] | v == append xs ys\n           && length v == length xs + length ys}"
86:39-86:41::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0}"
86:42-86:44::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"
96:1-96:20::Language.Stitch.LH.Data.List.elemAtThroughAppend :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> x2:{VV : [a] | x1 < length VV} -> x3:[a] -> {VV : () | elemAt x1 (append x2 x3) == elemAt x1 x2}"
96:21-96:22::i :: "{VV : GHC.Types.Int | VV >= 0}"
96:23-96:25::xs :: "{VV : [a] | i < length VV}"
96:26-96:28::ys :: "[a]"
97:6-97:7::i :: "{v : GHC.Types.Int | v == i\n                     && v >= 0}"
97:11-97:12::lq_anf$##7205759403792804244 :: "GHC.Types.Int"
97:18-97:25::Language.Haskell.Liquid.ProofCombinators.trivial :: "{v : () | v == trivial}"
97:28-97:46::lq_anf$##7205759403792804252 :: "{v : () | length (append xs ys) == length xs + length ys}"
97:41-97:43::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0\n           && i < length v}"
97:44-97:46::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"
98:13-98:15::_ :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0\n           && i < length v}"
99:16-99:50::Language.Stitch.LH.Data.List.elemAtThroughAppend :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> x2:{VV : [a] | x1 < length VV} -> x3:[a] -> {VV : () | elemAt x1 (append x2 x3) == elemAt x1 x2}"
99:36-99:43::lq_anf$##7205759403792804251 :: "GHC.Types.Int"
99:37-99:38::i :: "{v : GHC.Types.Int | v == i\n                     && v >= 0}"
99:41-99:42::lq_anf$##7205759403792804250 :: "GHC.Types.Int"
99:44-99:47::xss :: "{v : [a] | v == xss\n           && len v >= 0\n           && length v >= 0}"
99:48-99:50::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"
100:11-100:18::Language.Haskell.Liquid.ProofCombinators.trivial :: "{v : () | v == trivial}"
100:21-100:39::lq_anf$##7205759403792804248 :: "{v : () | length (append xs ys) == length xs + length ys}"
100:34-100:36::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && length v >= 0\n           && i < length v}"
100:37-100:39::ys :: "{v : [a] | v == ys\n           && len v >= 0\n           && length v >= 0}"